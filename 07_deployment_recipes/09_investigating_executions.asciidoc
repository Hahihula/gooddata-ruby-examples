=== Investigating Executions
by Tomas Svarovsky

==== Problem
You have large amount of projects and would like to investigate the execution. The administration UI is not necessarilly helpful since its overview UI can hide some failures etc.

==== Solution

Let's have a look at couple of scenarios. First let's investigate a executions inside one project regardless of which schedule it was triggered by. Let's assume first that we are just looking for any executions that failed for that particular project. We will print the date when it happend sorted in a ascending fashion.

[source,ruby]
----
# encoding: utf-8

require 'gooddata'

GoodData.with_connection do |client|
  GoodData.with_project('project_id') do |project|
    results = project.schedules
                     .pmapcat { |s| s.executions.to_a }
                     .select(&:error?)
    pp results.map(&:started).sort.uniq
  end
end

----

Now imagine that you are looking for executions executed by a particular schedule.

[source,ruby]
----
# encoding: utf-8

require 'gooddata'

GoodData.with_connection do |client|
  GoodData.with_project('project_id') do |project|
    results = project.schedules
                     .select { |s| s.name == 'user_filters_schedule' }
                     .pmapcat { |s| s.executions.to_a }
                     .select(&:error?)
    pp results.map(&:started).sort.uniq
  end
end

----

Lets' make it even more specific and let's look for a specific term in the error message/ Let's say that "unsynchronized" is the word we are looking for

[source,ruby]
----
# encoding: utf-8

require 'gooddata'

GoodData.with_connection do |client|
  GoodData.with_project('project_id') do |project|
    results = project.schedules
                     .select { |s| s.name == 'user_filters_schedule' }
                     .pmapcat { |s| s.executions.to_a }
                     .select(&:error?)
                     .select { |e| e.json['execution']['error']['message'] =~ /unsynchronized/ } # this is little crude. Factor out to a method
    pp results.map(&:started).sort.uniq
  end
end

----

Sometimes the error does not manfiest itself in the error message directly and you need to look into logs. Take not that in last both cases we are getting the log and the error message as a string so you have full power of ruby to process it. Here we are using regular expressions which by itself give you siginificant power but you can go even deeper if you need.

[source,ruby]
----
# encoding: utf-8

require 'gooddata'

GoodData.with_connection do |client|
  GoodData.with_project('project_id') do |project|
    results = project.schedules
                     .select { |s| s.name == 'user_filters_schedule' }
                     .pmapcat { |s| s.executions.to_a }
                     .select(&:error?)
                     .select { |e| e.log =~ /unsynchronized/ } # this is little crude. Factor out to a method
    pp results.map(&:started).sort.uniq
  end
end

----

Last example we will show is just a small extension. Imagine you would like to perform the same analysis on all projects in your account. This is usually the case since this type of analysing executions get exponentially more useful with growing number of executions or projects you need to investigate.

[source,ruby]
----
# encoding: utf-8

require 'gooddata'

GoodData.with_connection do |client|
    results = client.projects
                    .pmapcat(&:schedules)
                    .select { |s| s.name == 'user_filters_schedule' }
                    .pmapcat { |s| s.executions.to_a }
                    .select(&:error?)
                    .select { |e| e.log =~ /unsynchronized/ } # this is little crude. Factor out to a method
    pp results.map(&:started).sort.uniq
end

----
